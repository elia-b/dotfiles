#!/usr/bin/env bash
# This is a small script to keep track of my local repositories
# gitcheck -> gives an overview
# gitcheck add [path] -> adds the given path to the paths to check

CONFIG_FILE="$HOME/.local/gitcheck/.gitcheck"

# Define text colors
BLACK='\e[30m'
RED='\e[31m'
GREEN='\e[32m'
YELLOW='\e[33m'
BLUE='\e[34m'
MAGENTA='\e[35m'
CYAN='\e[36m'
WHITE='\e[37m'
RESET='\e[0m'

add_path() {
    # Function to add a path to the file
    
    local path="$1"
    # Expand ~, . and ..
    path=$(realpath "$path" 2>/dev/null || readlink -f "$path")

    if [[ -z "$path" ]]; then
        echo "Usage: $0 add /path/to/repo"
        exit 1
    fi

    if ! [[ -d "$path" ]]; then
        echo "Error: '$path' is not a directory"
        exit 1
    fi

    mkdir -p "$(dirname "$CONFIG_FILE")"

    # Avoid duplicates
    if grep -Fxq "$path" "$CONFIG_FILE" 2>/dev/null; then
        echo "Path already exists in $CONFIG_FILE"
    else
        echo "$path" >> "$CONFIG_FILE"
        echo "Added: $path"
    fi
}

# If "add" command used
if [[ "$1" == "add" ]]; then
    add_path "$2"
    exit 0
fi

# Ensure file exists
if [[ ! -f "$CONFIG_FILE" ]]; then
    echo "File not found: $CONFIG_FILE"
    exit 1
fi

# --- Flags ---
FETCH=false
HELP=false

# Parse flags
while getopts "Fh" opt; do
  case $opt in
    F) FETCH=true ;;
    h) HELP=true ;;
  esac
done
shift $((OPTIND - 1))

if $HELP; then
    printf "%b" "\
${CYAN}gitcheck${RESET} - Overview and management of your local Git repositories.

Usage:
  ${GREEN}gitcheck${RESET}                 Show status of all tracked repositories
  ${GREEN}gitcheck add [path]${RESET}     Add a local repository path to track
  ${GREEN}gitcheck -F${RESET}            Fetch updates from remotes before showing status
  ${GREEN}gitcheck -h${RESET}            Display this help message

Status Legend:
  ${GREEN} RepoName${RESET}              Up-to-date with remote
  ${BLUE} RepoName (behind)${RESET}      Local is behind remote
  ${CYAN} RepoName (ahead)${RESET}       Local is ahead of remote
  ${MAGENTA} RepoName (diverged ⚠️)${RESET} Local and remote have diverged
  ${YELLOW} RepoName (no upstream)${RESET} No remote upstream configured
  ${RED} RepoName${RESET}                Has local changes
  ${WHITE} RepoName${RESET}              Not a Git repository

Examples:
  ${GREEN}gitcheck add ~/projects/myrepo${RESET}  Add a new repository to track
  ${GREEN}gitcheck -F${RESET}                     Check all repos and fetch updates

"
    exit 0
fi


# Sort file by basename while keeping full path
sorted_paths=$(awk -F/ '{print $0 "\t" $NF}' "$CONFIG_FILE" | sort -k2 | cut -f1)

# Iterate through the paths
while IFS= read -r path; do
    [[ -z "$path" ]] && continue
    eval path="$path"  # expand ~
    repo_name=$(basename "$path")

    if [[ -d "$path/.git" ]]; then
        # Move to repo then come back
        pushd "$path" >/dev/null 2>&1
        if [[ -n "$(git status --porcelain 2>/dev/null)" ]]; then
            echo -e "${RED} ${repo_name}${RESET}"
            git diff --stat
        else
            # Fetch remote silently
            if $FETCH; then
                git fetch origin >/dev/null 2>&1
            fi

            # Check remote tracking info
            local=$(git rev-parse @ 2>/dev/null)
            remote=$(git rev-parse @{u} 2>/dev/null || echo "")
            base=$(git merge-base @ @{u} 2>/dev/null || echo "")

            # Decide color/icon based on ahead/behind/diverged status
            if [[ -z "$remote" ]]; then
                echo -e "${YELLOW} ${repo_name} (no upstream)${RESET}"
            elif [[ "$local" == "$remote" ]]; then
                echo -e "${GREEN} ${repo_name}${RESET}"
            elif [[ "$local" == "$base" ]]; then
                echo -e "${BLUE} ${repo_name} (behind)${RESET}"
            elif [[ "$remote" == "$base" ]]; then
                echo -e "${CYAN} ${repo_name} (ahead)${RESET}"
            else
                echo -e "${MAGENTA} ${repo_name} (diverged ⚠️)${RESET}"
            fi
        fi
        popd >/dev/null 2>&1
    else
        echo -e "${WHITE} ${repo_name}${RESET}"
    fi
done <<< "$sorted_paths"
